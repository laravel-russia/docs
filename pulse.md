---
git: 2d2cfae706c9367ebf19e13175dc1de2711cad7a
---


# Laravel Pulse

<a name="introduction"></a>
## Введение

[Laravel Pulse](https://github.com/laravel/pulse) предоставляет быстрый обзор производительности и использования вашего приложения. С помощью Pulse вы можете выявить узкие места, такие как медленные задания и конечные точки, найти ваших самых активных пользователей и многое другое.

Для подробной отладки отдельных событий рекомендуется ознакомиться с [Laravel Telescope](/docs/{{version}}/telescope).

<a name="installation"></a>
## Установка

> [!WARNING]
> В настоящее время для хранения данных Pulse используется собственная реализация, требующая базу данных MySQL, MariaDB или PostgreSQL. Если вы используете другой движок базы данных, вам потребуется отдельная база данных MySQL, MariaDB или PostgreSQL для хранения данных Pulse.

Вы можете установить Pulse с помощью менеджера пакетов Composer:

```sh
composer require laravel/pulse
```

Затем вам следует опубликовать конфигурационные файлы Pulse и файлы миграций, используя команду Artisan `vendor:publish`:

```shell
php artisan vendor:publish --provider="Laravel\Pulse\PulseServiceProvider"
```

Наконец, выполните команду `migrate`, чтобы создать таблицы, необходимые для хранения данных Pulse:

```shell
php artisan migrate
```

После выполнения миграций вы сможете получить доступ к информационной панели Pulse по маршруту `/pulse`.

> [!NOTE]
> Если вы не хотите хранить данные Pulse в основной базе данных вашего приложения, вы можете [указать отдельное соединение с базой данных](#using-a-different-database).

<a name="configuration"></a>
### Конфигурация

Многие параметры конфигурации Pulse могут быть установлены через переменные среды. Чтобы увидеть доступные опции, зарегистрировать новые регистраторы(recorders) или настроить дополнительные параметры, вы можете опубликовать файл конфигурации `config/pulse.php`:

```sh
php artisan vendor:publish --tag=pulse-config
```

<a name="dashboard"></a>
## Информационная панель

<a name="dashboard-authorization"></a>
### Авторизация

Доступ к информационной панели Pulse можно получить по маршруту `/pulse`. По умолчанию вы сможете получить доступ к информационной панели только в среде `local`, поэтому вам нужно будет настроить авторизацию для ваших производственных сред, настраивая шлюз авторизации (gate) `'viewPulse'`. Вы можете сделать это в файле `app/Providers/AppServiceProvider.php` вашего приложения:

```php
use App\Models\User;
use Illuminate\Support\Facades\Gate;

/**
 * Загрузка любых сервисов приложения.
 */
public function boot(): void
{
    Gate::define('viewPulse', function (User $user) {
        return $user->isAdmin();
    });

    // ...
}
```

<a name="dashboard-customization"></a>
### Настройка

Карточки и макет информационной панели Pulse можно настроить, опубликовав представление(view) информационной панели. Представление информационной панели будет опубликовано в `resources/views/vendor/pulse/dashboard.blade.php`:

```sh
php artisan vendor:publish --tag=pulse-dashboard
```

Информационная панель работает на [Livewire](https://livewire.laravel.com/) и позволяет настраивать карточки и макет без необходимости перестройки каких-либо JavaScript-ресурсов.

Внутри этого файла компонент `<x-pulse>` отвечает за отображение информационной панели и обеспечивает сетку(grid) для карточек. Если вы хотите, чтобы информационная панель распространялась на всю ширину экрана, вы можете предоставить компоненту атрибут `full-width`:

```blade
<x-pulse full-width>
    ...
</x-pulse>
```

По умолчанию компонент `<x-pulse>` создает сетку из 12 столбцов, но вы можете настроить это с помощью атрибута `cols`:

```blade
<x-pulse cols="16">
    ...
</x-pulse>
```

Каждая карточка принимает атрибуты `cols` и `rows`, чтобы управлять пространством и позиционированием:

```blade
<livewire:pulse.usage cols="4" rows="2" />
```

Большинство карточек также принимают атрибут `expand`, чтобы показать полную карточку вместо прокрутки:

```blade
<livewire:pulse.slow-queries expand />
```

<a name="dashboard-resolving-users"></a>
### Разрешение пользователей

Для карточек, отображающих информацию о ваших пользователях, таких как карточка использования приложения, Pulse записывает только идентификатор пользователя. При рендеринге информационной панели Pulse из вашей модели `Authenticatable` будет извлечены поля `name` и `email`, а также будет отображаться аватар с использованием веб-сервиса Gravatar.

Вы можете настроить поля и аватар, вызвав метод `Pulse::user` в классе `App\Providers\AppServiceProvider` вашего приложения.

Метод `user` принимает замыкание, которое будет получать модель `Authenticatable`, которая будет отображаться, и должен возвращать массив с информацией о `name`, `extra` и `avatar` для пользователя:

```php
use Laravel\Pulse\Facades\Pulse;

/**
 * Загрузка любых сервисов приложения.
 */
public function boot(): void
{
    Pulse::user(fn ($user) => [
        'name' => $user->name,
        'extra' => $user->email,
        'avatar' => $user->avatar_url,
    ]);

    // ...
}
```

> [!NOTE]
> Вы можете полностью настроить захват и извлечение аутентифицированного пользователя, реализовав контракт `Laravel\Pulse\Contracts\ResolvesUsers` и привязав его к [контейнеру служб Laravel](/docs/{{version}}/container#binding-a-singleton).

<a name="dashboard-cards"></a>
### Cards

<a name="servers-card"></a>
#### Серверы

Карточка `<livewire:pulse.servers />` отображает использование системных ресурсов для всех серверов, выполняющих команду `pulse:check`. Пожалуйста, обратитесь к документации о [регистраторе серверов](#servers-recorder) для получения дополнительной информации об отчетах использования системных ресурсов.

Если вы заменяете сервер в своей инфраструктуре, возможно, вы захотите прекратить отображение неактивного сервера на панели управления Pulse по истечении определенного периода времени. Вы можете сделать это, используя опцию `ignore-after`, которая принимает количество секунд, по истечении которых неактивные серверы должны быть удалены с панели управления Pulse. Альтернативно вы можете указать строку в формате относительного времени, например `1 hour` или `3 days and 1 hour`:

```blade
<livewire:pulse.servers ignore-after="3 hours" />
```

<a name="application-usage-card"></a>
#### Использование приложения

Карточка `<livewire:pulse.usage />` отображает топ-10 пользователей, отправляющих запросы к вашему приложению, обрабатывающих задачи и испытывающих медленные запросы.

Если вы хотите просмотреть все метрики использования на экране одновременно, вы можете включить карточку несколько раз и указать атрибут `type`:

```blade
<livewire:pulse.usage type="requests" />
<livewire:pulse.usage type="slow_requests" />
<livewire:pulse.usage type="jobs" />
```

Чтобы узнать, как настроить способ получение и отображения информации о пользователях в Pulse, обратитесь к нашей документации по [разрешению пользователей](#dashboard-resolving-users).

> [!NOTE]
> Если ваше приложение получает много запросов или отправляет много задач, вы можете захотеть включить [выборку](#sampling). См. документацию по [регистратору запросов пользователей](#user-requests-recorder), [регистратору задач пользователей](#user-jobs-recorder) и [регистратору медленных задач](#slow-jobs-recorder) для получения дополнительной информации.

<a name="exceptions-card"></a>
#### Исключения

Карточка `<livewire:pulse.exceptions />` отображает частоту и давность исключений, возникающих в вашем приложении. По умолчанию исключения группируются на основе класса исключения и места его возникновения. Дополнительную информацию можно найти в документации по [регистратору исключений](#exceptions-recorder).

<a name="queues-card"></a>
#### Очереди

Карточка `<livewire:pulse.queues />` отображает пропускную способность очередей в вашем приложении, включая количество добавленных в очередь, обрабатываемых, обработанных, выпущенных и неудачных задач. Дополнительную информацию можно найти в документации по [регистратору очередей](#queues-recorder).

<a name="slow-requests-card"></a>
#### Медленные HTTP запросы

Карточка `<livewire:pulse.slow-requests />` отображает входящие запросы к вашему приложению, время выполнения которых превышает настроенный порог, по умолчанию составляющий 1 000 мс. Дополнительную информацию можно найти в документации по [регистратору медленных Http запросов](#slow-requests-recorder).

<a name="slow-jobs-card"></a>
#### Медленные задачи

Карточка `<livewire:pulse.slow-jobs />` отображает задачи, находящиеся в очереди вашего приложения, время выполнения которых превышает настроенный порог, по умолчанию составляющий 1 000 мс. Дополнительную информацию можно найти в документации по [регистратору медленных задач](#slow-jobs-recorder).

<a name="slow-queries-card"></a>
#### Медленные запросы к базе данных

Карточка `<livewire:pulse.slow-queries />` отображает запросы к базе данных вашего приложения, время выполнения которых превышает настроенный порог, по умолчанию составляющий 1 000 мс.

По умолчанию медленные запросы группируются на основе SQL-запроса (без подстановок) и места, где он был выполнен, но вы можете выбрать не захватывать местоположение, если хотите группировать исключительно по SQL-запросу.

Если вы столкнулись с проблемами производительности рендеринга из-за очень больших SQL-запросов, получающих подсветку синтаксиса, вы можете отключить подсветку, добавив параметр `without-highlighting`:

```blade
<livewire:pulse.slow-queries without-highlighting />
```

См. документацию по [регистратору медленных запросов к базе данных](#slow-queries-recorder) для получения дополнительной информации.

<a name="slow-outgoing-requests-card"></a>
#### Медленные исходящие HTTP запросы

Карточка `<livewire:pulse.slow-outgoing-requests />` отображает исходящие запросы, сделанные с использованием [HTTP-клиента Laravel](/docs/{{version}}/http-client), время выполнения которых превышает настроенный порог, по умолчанию составляющий 1 000 мс.

По умолчанию записи будут группироваться по полному URL. Однако вы можете захотеть нормализовать или группировать подобные исходящие запросы с использованием регулярных выражений. См. документацию по [регистратору медленных исходящих HTTP запросов](#slow-outgoing-requests-recorder) для получения дополнительной информации.

<a name="cache-card"></a>
#### Кэш

Карточка `<livewire:pulse.cache />` отображает статистику зффективности использования кэша для вашего приложения, как глобально, так и для отдельных ключей.

По умолчанию записи будут группироваться по ключу. Однако вы можете захотеть нормализовать или группировать подобные ключи с использованием регулярных выражений. См. документацию по [записи взаимодействия с кэшем](#cache-interactions-recorder) для получения дополнительной информации.

<a name="capturing-entries"></a>
## Захват записей

Большинство регистраторов Pulse автоматически захватывают записи на основе событий фреймворка, отправляемых Laravel. Однако [регистратор серверов](#servers-recorder) и некоторые сторонние карточки должны регулярно запрашивать информацию. Чтобы использовать эти карточки, вы должны запустить демона `pulse:check` на всех ваших отдельных серверах приложения:

```php
php artisan pulse:check
```

> [!NOTE]
> Чтобы процесс `pulse:check` постоянно работал в фоновом режиме, вы должны использовать монитор процессов, такой как Supervisor, чтобы гарантировать, что команда не прекратит выполнение.

Поскольку команда `pulse:check` работает в течение длительного времени, она не будет замечать изменения в вашем коде без перезапуска. Во время развёртывания вашего приложения необходимо перезапустить команду с помощью вызова `pulse:restart`:

```sh
php artisan pulse:restart
```

> [!NOTE]
> Pulse использует [кэш](/docs/{{version}}/cache) для сохранения сигналов о перезапуске, поэтому перед использованием этой функции убедитесь, что драйвер кэша настроен правильно для вашего приложения.

<a name="recorders"></a>
### Регистраторы (Recorders)

Регистраторы отвечают за захват записей из вашего приложения для записи в базу данных Pulse. Регистраторы регистрируются и настраиваются в разделе `recorders` [файла конфигурации Pulse](#configuration).

<a name="cache-interactions-recorder"></a>
#### Взаимодействие с кешем

Регистратор `CacheInteractions` захватывает информацию о попаданиях и промахах кеша, происходящих в вашем приложении, для отображения в карточке [Cache](#cache-card).

Вы можете опционально настроить [уровень выборки](#sampling) и шаблоны игнорируемых ключей.

Вы также можете настроить группировку ключей так, чтобы похожие ключи группировались как одна запись. Например, вы можете удалить уникальные идентификаторы из ключей, кеширующих один и тот же тип информации. Группы настраиваются с использованием регулярного выражения для "поиска и замены" частей ключа. Пример включен в файле конфигурации:

```php
Recorders\CacheInteractions::class => [
    // ...
    'groups' => [
        // '/:\d+/' => ':*',
    ],
],
```

Будет использоваться первый подходящий шаблон. Если ни один шаблон не подошёл, то ключ будет захвачен как есть.

<a name="exceptions-recorder"></a>
#### Исключения

Регистратор `Exceptions` отслеживает информацию о возникающих в вашем приложении исключениях, подлежащих отчетности, для отображения в [карточке исключений](#exceptions-card).

Вы можете опционально настраивать [уровень выборки](#sampling) и шаблоны игнорируемых исключений. Также вы можете настроить захват местоположения, откуда произошло исключение. Захваченное местоположение будет отображаться на панели управления Pulse, что может помочь отследить источник исключения; однако, если одно и то же исключение возникает в нескольких местах, оно будет отображаться несколько раз для каждого уникального местоположения.

<a name="queues-recorder"></a>
#### Очереди

Регистратор `Queues` отслеживает информацию о очередях вашего приложения для отображения на [карточке очередей](#queues-card).

Вы можете опционально настраивать [уровень выборки](#sampling) и шаблоны игнорируемых задач.

<a name="slow-jobs-recorder"></a>
#### Медленные задачи

Регистратор `SlowJobs` отслеживает информацию о медленных задачах, происходящих в вашем приложении, для отображения на карточке [Медленные задачи](#slow-jobs-recorder).

Вы можете опционально настраивать порог медленных задач, [уровень выборки](#sampling) и шаблоны игнорируемых задач.

У вас могут быть некоторые работы, которые, по вашему мнению, займут больше времени, чем другие. В этих случаях вы можете настроить пороговые значения для каждого задания:

```php
Recorders\SlowJobs::class => [
    // ...
    'threshold' => [
        '#^App\\Jobs\\GenerateYearlyReports$#' => 5000,
        'default' => env('PULSE_SLOW_JOBS_THRESHOLD', 1000),
    ],
],
```

Если ни один шаблон регулярного выражения не соответствует имени класса задания, то будет использовано значение `'default'`.

<a name="slow-outgoing-requests-recorder"></a>
#### Медленные Исходящие HTTP Запросы

Регистратор `SlowOutgoingRequests` отслеживает информацию об исходящих HTTP-запросах, сделанных с использованием [HTTP-клиента Laravel](/docs/{{version}}/http-client), которые превышают настроенный порог, для отображения в карточке [медленные исходящие HTTP запросы](#slow-outgoing-requests-card).

Вы можете опционально настраивать порог медленных исходящих запросов, [уровень выборки](#sampling) и шаблоны игнорируемых URL-адресов.

У вас могут быть некоторые исходящие запросы, которые, по вашему мнению, займут больше времени, чем другие. В этих случаях вы можете настроить пороговые значения для каждого запроса:

```php
Recorders\SlowOutgoingRequests::class => [
    // ...
    'threshold' => [
        '#backup.zip$#' => 5000,
        'default' => env('PULSE_SLOW_OUTGOING_REQUESTS_THRESHOLD', 1000),
    ],
],
```

Если ни один шаблон регулярного выражения не соответствует URL-адресу запроса, то будет использовано значение `'default'`.

Также вы можете настроить группировку URL-адресов, чтобы похожие URL-адреса были сгруппированы в один элемент. Например, вы можете удалить уникальные идентификаторы из путей URL или сгруппировать только по домену. Группы настраиваются с использованием регулярного выражения для "поиска и замены" частей URL-адреса. Некоторые примеры включены в файл конфигурации:

```php
Recorders\SlowOutgoingRequests::class => [
    // ...
    'groups' => [
        // '#^https://api\.github\.com/repos/.*$#' => 'api.github.com/repos/*',
        // '#^https?://([^/]*).*$#' => '\1',
        // '#/\d+#' => '/*',
    ],
],
```

Будет использоваться первый подходящий шаблон. Если ни один из шаблонов не подходит, то URL будет захвачен в исходном виде.

<a name="slow-queries-recorder"></a>
#### Медленные запросы к базе данных

Регистратор `SlowQueries` захватывает любые запросы к базе данных в вашем приложении, превышающие настроенный порог, для отображения в карточке [медленные запросы к базе данных](#slow-queries-card).

Вы можете опционально настраивать порог медленных запросов, [уровень выборки](#sampling) и шаблоны игнорируемых запросов. Вы также можете настроить захват местоположения запроса. Захваченное местоположение будет отображаться в информационной панели Pulse, что может помочь отследить источник запроса; однако, если один и тот же запрос выполняется в нескольких местах, он будет отображаться несколько раз для каждого уникального местоположения.

У вас могут быть некоторые запросы, которые, по вашему мнению, займут больше времени, чем другие. В этих случаях вы можете настроить пороговые значения для каждого запроса:

```php
Recorders\SlowQueries::class => [
    // ...
    'threshold' => [
        '#^insert into `yearly_reports`#' => 5000,
        'default' => env('PULSE_SLOW_QUERIES_THRESHOLD', 1000),
    ],
],
```

Если ни один шаблон регулярного выражения не соответствует SQL-запросу, то будет использовано значение `'default'`.

<a name="slow-requests-recorder"></a>
#### Медленные HTTP pапросы

Регистратор `Requests` захватывает информацию о http запросах к вашему приложению для отображения в карточках [медленные http запросы](#slow-requests-card) и [использование приложения](#application-usage-card).

Вы можете настраивать порог медленных маршрутов, [уровень выборки](#sampling) и игнорируемые пути.

У вас могут быть некоторые запросы, которые, по вашему мнению, займут больше времени, чем другие. В этих случаях вы можете настроить пороговые значения для каждого запроса:

```php
Recorders\SlowRequests::class => [
    // ...
    'threshold' => [
        '#^/admin/#' => 5000,
        'default' => env('PULSE_SLOW_REQUESTS_THRESHOLD', 1000),
    ],
],
```

Если ни один шаблон регулярного выражения не соответствует URL-адресу запроса, то будет использовано значение `'default'`.

<a name="servers-recorder"></a>
#### Серверы

Регистратор `Servers` захватывает информацию о загрузке процессора, памяти и хранилища серверов, обеспечивающих работу вашего приложения, для отображения в карточке [Серверы](#servers-card). Для работы этого регистратора необходимо, чтобы на каждом сервере, который вы хотите отслеживать, была запущена команда [`pulse:check`](#capturing-entries).

Каждый отслеживаемый сервер должен иметь уникальное имя. По умолчанию Pulse будет использовать значение, возвращаемое функцией `gethostname` PHP. Если вы хотите настроить это, вы можете установить переменную окружения `PULSE_SERVER_NAME`:

```env
PULSE_SERVER_NAME=load-balancer
```

Файл конфигурации Pulse также позволяет настраивать каталоги, которые будут отслеживаться.

<a name="user-jobs-recorder"></a>
#### Пользователи с задачами

Регистратор `UserJobs` захватывает информацию о пользователях, отправляющих задачи в вашем приложении, для отображения в карточке [использование приложения](#application-usage-card).

Вы можете опционально настраивать [уровень выборки](#sampling) и шаблоны игнорируемых задач.

<a name="user-requests-recorder"></a>
#### Пользователи с запросами

Регистратор `UserRequests` захватывает информацию о пользователях, делающих запросы к вашему приложению, для отображения в карточке [использование приложения](#application-usage-card).

Вы можете опционально настраивать [уровень выборки](#sampling) и шаблоны игнорируемых URL-адресов.

<a name="filtering"></a>
### Фильтрация

Как мы видели, многие [регистраторы](#recorders) предлагают возможность, через конфигурацию, "игнорировать" входящие записи на основе их значения, например, URL запроса. Однако иногда может быть полезно фильтровать записи на основе других факторов, таких как текущий аутентифицированный пользователь. Для фильтрации этих записей вы можете передать замыкание в метод `filter` Pulse. Обычно метод `filter` следует вызывать внутри метода `boot` `AppServiceProvider` вашего приложения:

```php
use Illuminate\Support\Facades\Auth;
use Laravel\Pulse\Entry;
use Laravel\Pulse\Facades\Pulse;
use Laravel\Pulse\Value;

/**
 * Загрузка любых сервисов приложения.
 */
public function boot(): void
{
    Pulse::filter(function (Entry|Value $entry) {
        return Auth::user()->isNotAdmin();
    });

    // ...
}
```

<a name="performance"></a>
## Производительность

Pulse был разработан для интеграции в существующее приложение без необходимости в дополнительной инфраструктуре. Однако, для приложений с высокой нагрузкой существует несколько способов уменьшить влияние, которое Pulse может оказать на производительность вашего приложения.

<a name="using-a-different-database"></a>
### Использование отдельной базы данных

Для приложений с высокой нагрузкой вы можете использовать для Pulse отдельное соединение с базой данных, чтобы избежать влияния на базу данных вашего приложения.

Вы можете настроить [соединение с базой данных](/docs/{{version}}/database#configuration), используемое Pulse, установив переменную окружения `PULSE_DB_CONNECTION`.

```env
PULSE_DB_CONNECTION=pulse
```

<a name="ingest"></a>
### Использование Redis

> [!WARNING]
> Для работы с Redis Ingest требуется Redis версии 6.2 или выше, а также `phpredis` или `predis` в качестве используемого драйвера клиента Redis.

По умолчанию Pulse сохраняет записи непосредственно в [настроенное соединение с базой данных](#using-a-different-database) после отправки HTTP-ответа клиенту или обработки задачи; однако вы можете использовать драйвер вывода в Redis от Pulse для отправки записей в поток Redis. Это можно включить, настроив переменную окружения `PULSE_INGEST_DRIVER`:

```
PULSE_INGEST_DRIVER=redis
```

По умолчанию Pulse будет использовать ваше стандартное [соединение с Redis](/docs/{{version}}/redis#configuration), но вы можете настроить это с помощью переменной окружения `PULSE_REDIS_CONNECTION`:

```
PULSE_REDIS_CONNECTION=pulse
```

При использовании вывода в Redis вам потребуется запустить команду `pulse:work` для отслеживания потока и перемещения записей из Redis в таблицы базы данных Pulse.

```php
php artisan pulse:work
```

> [!NOTE]
> Чтобы обеспечить постоянную работу процесса `pulse:work` в фоновом режиме, рекомендуется использовать монитор процессов, такой как Supervisor, чтобы гарантировать, что рабочий процесс Pulse не прекращает свою работу.

Поскольку команда `pulse:work` является долгоживущим процессом, она не увидит изменений в вашей кодовой базе без перезапуска. Вам следует корректно перезапустить команду, вызвав команду `pulse:restart` во время процесса развертывания вашего приложения:

```sh
php artisan pulse:restart
```

> [!NOTE]
> Pulse использует [кэш](/docs/{{version}}/cache) для хранения сигналов перезапуска, поэтому перед использованием этой функции вам следует убедиться, что драйвер кэша правильно настроен для вашего приложения.

<a name="sampling"></a>
### Выборка (Sampling)

По умолчанию Pulse будет захватывать каждое значимое событие, происходящее в вашем приложении. Для приложений с высокой нагрузкой это может привести к необходимости агрегировать миллионы строк из базы данных в информационную панель, особенно для более длительных временных периодов.

Вместо этого вы можете включить "выборку" для определенных регистраторов данных Pulse. Например, установка уровня выборки `0.1` для регистратора [`User Requests`](#user-requests-recorder) означает, что вы записываете только примерно 10% запросов к вашему приложению. В информационной панели значения будут масштабированы и снабжены префиксом `~`, указывающим на то, что они являются приблизительными.

В общем, чем больше записей у вас для конкретной метрики, тем ниже вы можете безопасно установить коэффициент выборки, не жертвуя большим количеством точности.

<a name="trimming"></a>
### Обрезка

Pulse автоматически обрезает свои сохраненные записи, когда они выходят за пределы окна информационной панели. Обрезка происходит при внесении данных с использованием системы лотереи, которую можно настроить в [файле конфигурации](#configuration) Pulse.

<a name="pulse-exceptions"></a>
### Обработка Исключений Pulse

Если происходит исключение во время захвата данных Pulse, например, если невозможно подключиться к базе данных хранилища, Pulse будет его игнорировать, чтобы избежать влияния на ваше приложение.

Если вы хотите настроить способ обработки этих исключений, вы можете предоставить замыкание методу `handleExceptionsUsing`:

```php
use Laravel\Pulse\Facades\Pulse;
use Illuminate\Support\Facades\Log;

Pulse::handleExceptionsUsing(function ($e) {
    Log::debug('Исключение произошло в Pulse', [
        'message' => $e->getMessage(),
        'stack' => $e->getTraceAsString(),
    ]);
});
```

<a name="custom-cards"></a>
## Пользовательские Карточки

Pulse позволяет создавать пользовательские карточки для отображения данных, соответствующих конкретным потребностям вашего приложения. Pulse использует [Livewire](https://livewire.laravel.com), поэтому вам может быть полезно [ознакомиться с его документацией](https://livewire.laravel.com/docs) перед созданием своей первой пользовательской карточки.

<a name="custom-card-components"></a>
### Компоненты Карточек

Создание пользовательской карточки в Laravel Pulse начинается с расширения базового компонента Livewire `Card` и определения соответствующего представления:

```php
namespace App\Livewire\Pulse;

use Laravel\Pulse\Livewire\Card;
use Livewire\Attributes\Lazy;

#[Lazy]
class TopSellers extends Card
{
    public function render()
    {
        return view('livewire.pulse.top-sellers');
    }
}
```

При использовании функции [ленивой загрузки](https://livewire.laravel.com/docs/lazy) Livewire, компонент `Card` автоматически предоставит заполнитель, который учитывает атрибуты `cols` и `rows`, переданные в ваш компонент.

При написании соответствующего представления карточки Pulse вы можете использовать компоненты Blade Pulse для обеспечения согласованного внешнего вида:

```blade
<x-pulse::card :cols="$cols" :rows="$rows" :class="$class" wire:poll.5s="">
    <x-pulse::card-header name="Top Sellers">
        <x-slot:icon>
            ...
        </x-slot:icon>
    </x-pulse::card-header>

    <x-pulse::scroll :expand="$expand">
        ...
    </x-pulse::scroll>
</x-pulse::card>
```

Переменные `$cols`, `$rows`, `$class` и `$expand` должны быть переданы соответствующим компонентам Blade, чтобы пользовательский макет карточки мог быть настроен из макета информационной панели. Вы также можете включить атрибут `wire:poll.5s=""` в вашем представлении, чтобы карточка обновлялась автоматически.

После того как вы определили свой компонент Livewire и шаблон, карточка может быть включена в ваше [представление информационной панели](#dashboard-customization):

```blade
<x-pulse>
    ...

    <livewire:pulse.top-sellers cols="4" />
</x-pulse>
```

> [!NOTE]
> Если ваша карточка включена в пакет, вам нужно зарегистрировать компонент в Livewire с помощью метода `Livewire::component`.

<a name="custom-card-styling"></a>
### Стилизация

Если вашей карточке требуется дополнительное оформление помимо классов и компонентов, включенных в Pulse, у вас есть несколько вариантов для включения пользовательских CSS для ваших карточек.

<a name="custom-card-styling-vite"></a>
#### Интеграция Laravel Vite

Если ваша пользовательская карточка находится в кодовой базе вашего приложения, и вы используете [интеграцию Laravel с Vite](/docs/{{version}}/vite), вы можете обновить файл `vite.config.js`, чтобы добавить отдельную точку входа для CSS вашей карточки:

```js
laravel({
    input: [
        'resources/css/pulse/top-sellers.css',
        // ...
    ],
}),
```

Затем вы можете использовать директиву Blade `@vite` в вашем [представлении информационной панели](#dashboard-customization), указав точку входа CSS для вашей карточки:

```blade
<x-pulse>
    @vite('resources/css/pulse/top-sellers.css')

    ...
</x-pulse>
```

<a name="custom-card-styling-css"></a>
#### CSS файлы

Для других случаев использования, включая карточки Pulse, содержащиеся в пакете, вы можете поручить Pulse загрузить дополнительные таблицы стилей, определив метод `css` в вашем компоненте Livewire, который возвращает путь к вашему CSS-файлу:

```php
class TopSellers extends Card
{
    // ...

    protected function css()
    {
        return __DIR__.'/../../dist/top-sellers.css';
    }
}
```

При подключении этой карточки в информационной панели Pulse автоматически добавит содержимое этого файла в тег `<style>`, поэтому его не нужно публиковать в каталог `public`.

<a name="custom-card-styling-tailwind"></a>
#### Tailwind CSS

При использовании Tailwind CSS рекомендуется создать отдельный файл конфигурации Tailwind, чтобы избежать загрузки ненужных CSS или конфликтов с классами Tailwind Pulse:

```js
export default {
    darkMode: 'class',
    important: '#top-sellers',
    content: [
        './resources/views/livewire/pulse/top-sellers.blade.php',
    ],
    corePlugins: {
        preflight: false,
    },
};
```

Затем вы можете указать файл конфигурации в точке входа CSS:

```css
@config "../../tailwind.top-sellers.config.js";
@tailwind base;
@tailwind components;
@tailwind utilities;
```

Вам также нужно будет включить в шаблоне вашей карточки атрибут `id` или `class` , который соответствует селектору, переданному в стратегию выбора [`important`](https://tailwindcss.com/docs/configuration#selector-strategy) в Tailwind:

```blade
<x-pulse::card id="top-sellers" :cols="$cols" :rows="$rows" class="$class">
    ...
</x-pulse::card>
```

<a name="custom-card-data"></a>
### Захват данных и их агрегация

Пользовательские карточки могут получать и отображать данные из любого места; однако вы можете воспользоваться мощной и эффективной системой записи и агрегации данных Pulse.

<a name="custom-card-data-capture"></a>
#### Захват записей

Pulse позволяет записывать "записи" с помощью метода `Pulse::record`:

```php
use Laravel\Pulse\Facades\Pulse;

Pulse::record('user_sale', $user->id, $sale->amount)
    ->sum()
    ->count();
```

Первый аргумент, передаваемый методу `record`, является `типом` записи, второй аргумент - это `ключ`, который определяет, как должны быть сгруппированы агрегированные данные. Для большинства методов агрегации вам также потребуется указать `значение`, которое должно быть агрегировано. В приведенном выше примере агрегируемое значение - `$sale->amount`. Затем вы можете вызвать один или несколько методов агрегации (например, `sum`), чтобы Pulse мог захватывать предварительно агрегированные значения в "корзины" для эффективного извлечения позже.

Доступные методы агрегации:

* `avg`
* `count`
* `max`
* `min`
* `sum`

> [!NOTE]
> При создании пакета карточек, который захватывает идентификатор текущего аутентифицированного пользователя, следует использовать метод `Pulse::resolveAuthenticatedUserId()`, который учитывает любые [настройки пользовательского разрешения](#dashboard-resolving-users), примененные в приложении.

<a name="custom-card-data-retrieval"></a>
#### Получение агрегированных данных

При расширении Pulse компонентом `Card` Livewire вы можете использовать метод `aggregate` для получения агрегированных данных за период, просматриваемый на информационной панели:

```php
class TopSellers extends Card
{
    public function render()
    {
        return view('livewire.pulse.top-sellers', [
            'topSellers' => $this->aggregate('user_sale', ['sum', 'count'])
        ]);
    }
}
```

Метод `aggregate` возвращает коллекцию объектов PHP `stdClass`. Каждый объект будет содержать свойство `key`, захваченное ранее, а также ключи для каждой запрошенной агрегации:

```
@foreach ($topSellers as $seller)
    {{ $seller->key }}
    {{ $seller->sum }}
    {{ $seller->count }}
@endforeach
```

Pulse в основном будет извлекать данные из предварительно агрегированных корзин; следовательно, указанные агрегаты должны быть получены заранее с помощью метода `Pulse::record`. Самая старая корзина обычно частично выходит за период, поэтому Pulse будет агрегировать старые записи, чтобы заполнить пробел и дать точное значение для всего периода, без необходимости в агрегации всего периода на каждый запрос.

Также можно получить общее значение для заданного типа, используя метод `aggregateTotal`. Например, следующий метод извлечет общую сумму всех продаж пользователей вместо их группировки по пользователям.

```php
$total = $this->aggregateTotal('user_sale', 'sum');
```

<a name="custom-card-displaying-users"></a>
#### Отображение Пользователей

При работе с агрегатами, которые записывают идентификатор пользователя в качестве ключа, вы можете разрешить ключи в записи пользователей, используя метод `Pulse::resolveUsers`:

```php
$aggregates = $this->aggregate('user_sale', ['sum', 'count']);

$users = Pulse::resolveUsers($aggregates->pluck('key'));

return view('livewire.pulse.top-sellers', [
    'sellers' => $aggregates->map(fn ($aggregate) => (object) [
        'user' => $users->find($aggregate->key),
        'sum' => $aggregate->sum,
        'count' => $aggregate->count,
    ])
]);
```

Метод `find` возвращает объект, содержащий ключи `name`, `extra` и `avatar`, которые вы можете опционально передать непосредственно в компонент Blade `<x-pulse::user-card>`:

```blade
<x-pulse::user-card :user="{{ $seller->user }}" :stats="{{ $seller->sum }}" />
```

<a name="custom-recorders"></a>
#### Пользовательские регистраторы

Авторы пакетов могут предоставить классы регистраторов, чтобы пользователи могли настраивать захват данных.

Регистраторы регистрируются в разделе `recorders` файла конфигурации `config/pulse.php` вашего приложения:

```php
[
    // ...
    'recorders' => [
        Acme\Recorders\Deployments::class => [
            // ...
        ],

        // ...
    ],
]
```

Регистраторы могут прослушивать события, указав свойство `$listen`. Pulse автоматически зарегистрирует слушателей и вызовет метод `record` регистратора:

```php
<?php

namespace Acme\Recorders;

use Acme\Events\Deployment;
use Illuminate\Support\Facades\Config;
use Laravel\Pulse\Facades\Pulse;

class Deployments
{
    /**
     * События, которые стоит слушать.
     *
     * @var array<int, class-string>
     */
    public array $listen = [
        Deployment::class,
    ];

    /**
     * Запишите развертывание.
     */
    public function record(Deployment $event): void
    {
        $config = Config::get('pulse.recorders.'.static::class);

        Pulse::record(
            // ...
        );
    }
}
```
