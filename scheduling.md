---
git: ace0221459d884e41a90aa4c3a23cff35248a5d4
---

# Планирование задач

<a name="introduction"></a>
## Введение

В прошлом вы могли создавать запись конфигурации cron для каждой задачи, которую нужно было запланировать на своем сервере. Однако это может быстро стать проблемой, потому что ваше расписание задач не находится в системе управления версиями и вы должны подключаться по SSH для просмотра существующих записей cron или добавления дополнительных записей.

Планировщик команд Laravel предлагает новый подход к управлению запланированными задачами на вашем сервере. Планировщик позволяет вам быстро и выразительно определять расписание команд в самом приложении Laravel. При использовании планировщика на вашем сервере требуется только одна запись cron. Расписание задач обычно определяется в файле `routes/console.php` вашего приложения.

<a name="defining-schedules"></a>
## Определение расписаний

Вы можете определить все запланированные задачи в файле `routes/console.php` вашего приложения. Для начала рассмотрим пример. В этом примере мы определим замыкание, которое будет вызываться каждый день в полночь. В замыкании мы выполним запрос к базе данных для очистки таблицы:

    <?php

    use Illuminate\Support\Facades\DB;
    use Illuminate\Support\Facades\Schedule;

    Schedule::call(function () {
        DB::table('recent_users')->delete();
    })->daily();

В дополнение к планированию с использованием замыканий вы также можете использовать [вызываемые объекты](https://www.php.net/manual/ru/language.oop5.magic.php#language.oop5.magic.invoke). Вызываемые объекты – это простые классы PHP, содержащие метод `__invoke`:

    Schedule::call(new DeleteRecentUsers)->daily();

Если вы предпочитаете зарезервировать файл `routes/console.php` только для определений команд, вы можете использовать метод `withSchedule` в файле `bootstrap/app.php` вашего приложения для определения запланированных задач. Этот метод принимает замыкание, которое получает экземпляр планировщика:

    use Illuminate\Console\Scheduling\Schedule;

    ->withSchedule(function (Schedule $schedule) {
        $schedule->call(new DeleteRecentUsers)->daily();
    })

Если вы хотите просмотреть список ваших запланированных задач и их последующего запуска, то вы можете использовать команду `schedule:list` Artisan:

```bash
php artisan schedule:list
```

<a name="scheduling-artisan-commands"></a>
### Планирование команд Artisan

В дополнение к планированию с использованием замыканий вы также можете использовать [команды Artisan](artisan) и системные команды. Например, вы можете использовать метод `command` для планирования команды Artisan, используя имя команды или класс.

При планировании команд Artisan с использованием имени класса команды вы можете передать массив дополнительных аргументов командной строки, которые должны быть переданы команде при ее вызове:

    use App\Console\Commands\SendEmailsCommand;
    use Illuminate\Support\Facades\Schedule;

    Schedule::command('emails:send Taylor --force')->daily();

    Schedule::command(SendEmailsCommand::class, ['Taylor', '--force'])->daily();

<a name="scheduling-artisan-closure-commands"></a>
#### Планирование команд закрытия Artisan

Если вы хотите запланировать команду Artisan, определенную замыканием, вы можете связать методы, связанные с планированием, после определения команды:

    Artisan::command('delete:recent-users', function () {
        DB::table('recent_users')->delete();
    })->purpose('Удалить недавних пользователей')->daily();

Если вам нужно передать аргументы команде закрытия, вы можете передать их методу `schedule`:

    Artisan::command('emails:send {user} {--force}', function ($user) {
        // ...
    })->purpose('Отправлять электронные письма указанному пользователю')->schedule(['Taylor', '--force'])->daily();

<a name="scheduling-queued-jobs"></a>
### Планирование отправки заданий в очереди

Метод `job` используется для планирования отправки [задания в очередь](/docs/{{version}}/queues). Этот метод обеспечивает удобный способ планирования таких заданий без использования метода `call` с замыканием:

    use App\Jobs\Heartbeat;
    use Illuminate\Support\Facades\Schedule;

    Schedule::job(new Heartbeat)->everyFiveMinutes();

Необязательные второй и третий аргументы могут быть переданы методу `job` для указания имени очереди и соединения очереди, которые должны использоваться для постановки задания в очередь:

    use App\Jobs\Heartbeat;
    use Illuminate\Support\Facades\Schedule;

    // Отправляем задание в очередь «heartbeats» соединения «sqs»...
    Schedule::job(new Heartbeat, 'heartbeats', 'sqs')->everyFiveMinutes();

<a name="scheduling-shell-commands"></a>
### Планирование команд операционной системы

Метод `exec` используется для передачи команды операционной системе:

    use Illuminate\Support\Facades\Schedule;

    Schedule::exec('node /home/forge/script.js')->daily();

<a name="schedule-frequency-options"></a>
### Параметры периодичности расписания

Мы уже видели несколько примеров того, как можно настроить задачу на выполнение через определенные промежутки времени. Однако существует гораздо больше параметров планирования, которые можно назначить задаче:

<div class="overflow-auto">

| Метод                              | Описание                                                 |
| ---------------------------------- | -------------------------------------------------------- |
| `->cron('* * * * *');`             | Запустить задачу по расписанию с параметрами cron        |
| `->everySecond();`                 | Запускать задачу ежесекундно                             |
| `->everyTwoSeconds();`             | - каждые 2 секунды                                       |
| `->everyFiveSeconds();`            | - каждые 5 секунд                                        |
| `->everyTenSeconds();`             | - каждые 10 секунд                                       |
| `->everyFifteenSeconds();`         | - каждые 15 секунд                                       |
| `->everyTwentySeconds();`          | - каждые 20 секунд                                       |
| `->everyThirtySeconds();`          | - каждые 30 секунд                                       |
| `->everyMinute();`                 | Запускать задачу ежеминутно                              |
| `->everyTwoMinutes();`             | – каждые 2 минуты                                        |
| `->everyThreeMinutes();`           | – каждые 3 минуты                                        |
| `->everyFourMinutes();`            | – каждые 4 минуты                                        |
| `->everyFiveMinutes();`            | – каждые 5 минут                                         |
| `->everyTenMinutes();`             | – каждые 10 минут                                        |
| `->everyFifteenMinutes();`         | – каждые 15 минут                                        |
| `->everyThirtyMinutes();`          | – каждые 30 минут                                        |
| `->hourly();`                      | – каждый час                                             |
| `->hourlyAt(17);`                  | – в 17 минут каждого часа                                |
| `->everyOddHour($minutes = 0);`    | - каждый нечетный час                                    |
| `->everyTwoHours($minutes = 0);`   | - каждые 2 часа                                          |
| `->everyThreeHours($minutes = 0);` | - каждые 3 часа                                          |
| `->everyFourHours($minutes = 0);`  | - каждые 4 часа                                          |
| `->everySixHours($minutes = 0);`   | - каждые 6 часов                                         |
| `->daily();`                       | – каждый день в полночь                                  |
| `->dailyAt('13:00');`              | – ежедневно в 13:00                                      |
| `->twiceDaily(1, 13);`             | – ежедневно дважды в день: дважды в день: в 1:00 и 13:00 |
| `->twiceDailyAt(1, 13, 15);`       | - ежедневно в 1:15 и 13:15.                              |
| `->weekly();`                      | – еженедельно в воскресенье в 00:00                      |
| `->weeklyOn(1, '8:00');`           | – еженедельно в понедельник в 8:00                       |
| `->monthly();`                     | – ежемесячно первого числа в 00:00                       |
| `->monthlyOn(4, '15:00');`         | – ежемесячно 4 числа в 15:00                             |
| `->twiceMonthly(1, 16, '13:00');`  | – ежемесячно дважды в месяц: 1 и 16 числа в 13:00        |
| `->lastDayOfMonth('15:00');`       | – ежемесячно в последний день месяца в 15:00             |
| `->quarterly();`                   | – ежеквартально в первый день в 00:00                    |
| `->quarterlyOn(4, '14:00');`       | - ежеквартально в 4-й день в 14:00.                      |
| `->yearly();`                      | – ежегодно в первый день в 00:00                         |
| `->yearlyOn(6, 1, '17:00');`       | – ежегодно в июне первого числа в 17:00                  |
| `->timezone('America/New_York');`  | Установить часовой пояс для задачи                       |

</div>

Эти методы можно комбинировать с дополнительными ограничениями для создания еще более точных расписаний, которые выполняются только в определенные дни недели. Например, вы можете запланировать выполнение команды еженедельно в понедельник:

    use Illuminate\Support\Facades\Schedule;

    // Запускаем раз в неделю в понедельник в 13:00...
    Schedule::call(function () {
        // ...
    })->weekly()->mondays()->at('13:00');

    // Запускаем по будням ежечасно с 8 утра до 5 вечера...
    Schedule::command('foo')
              ->weekdays()
              ->hourly()
              ->timezone('America/Chicago')
              ->between('8:00', '17:00');

Список дополнительных ограничений расписания можно найти ниже:

<div class="overflow-auto">

| Метод                                    | Описание                                                   |
| ---------------------------------------- | ---------------------------------------------------------- |
| `->weekdays();`                          | Ограничить выполнение задачи рабочими днями                |
| `->weekends();`                          | – выходными днями                                          |
| `->sundays();`                           | – воскресным днем                                          |
| `->mondays();`                           | – понедельником                                            |
| `->tuesdays();`                          | – вторником                                                |
| `->wednesdays();`                        | – средой                                                   |
| `->thursdays();`                         | – четвергом                                                |
| `->fridays();`                           | – пятницей                                                 |
| `->saturdays();`                         | – субботой                                                 |
| `->days(array\|mixed);`                  | – определенными днями
| `->between($startTime, $endTime);`       | – временными интервалами начала и окончания                |
| `->unlessBetween($startTime, $endTime);` | – через исключение временных интервалов начала и окончания |
| `->when(Closure);`                       | – на основе истинности результата выполненного замыкания   |
| `->environments($env);`                  | – окружением выполнения                                    |

</div>

<a name="day-constraints"></a>
#### Дневные ограничения

Метод `days` можно использовать для ограничения выполнения задачи определенными днями недели. Например, вы можете запланировать выполнение команды ежечасно по воскресеньям и средам:

    use Illuminate\Support\Facades\Schedule;

    Schedule::command('emails:send')
                    ->hourly()
                    ->days([0, 3]);

В качестве альтернативы вы можете использовать константы, доступные в классе `Illuminate\Console\Scheduling\Schedule`, при указании дней, в которые должна выполняться задача:

    use Illuminate\Support\Facades;
    use Illuminate\Console\Scheduling\Schedule;

    Facades\Schedule::command('emails:send')
                    ->hourly()
                    ->days([Schedule::SUNDAY, Schedule::WEDNESDAY]);

<a name="between-time-constraints"></a>
#### Ограничения с временными интервалами

Метод `between` может использоваться для ограничения выполнения задачи в зависимости от времени суток:

    Schedule::command('emails:send')
                        ->hourly()
                        ->between('7:00', '22:00');

Точно так же метод `unlessBetween` может использоваться для исключения определенных периодов времени выполнения задачи:

    Schedule::command('emails:send')
                        ->hourly()
                        ->unlessBetween('23:00', '4:00');

<a name="truth-test-constraints"></a>
#### Условные ограничения

Метод `when` может использоваться для ограничения выполнения задачи на основе истинности результата выполненного замыкания. Другими словами, если переданное замыкание возвращает `true`, то задача будет выполняться до тех пор, пока никакие другие ограничивающие условия не препятствуют ее запуску:

    Schedule::command('emails:send')->daily()->when(function () {
        return true;
    });

Метод `skip` можно рассматривать как противоположный методу `when`. Если метод `skip` возвращает `true`, то запланированная задача не будет выполнена:

    Schedule::command('emails:send')->daily()->skip(function () {
        return true;
    });

При использовании цепочки методов `when`, запланированная команда будет выполняться только в том случае, если все условия `when` возвращают значение `true`.

<a name="environment-constraints"></a>
#### Ограничения окружения выполнения

Метод `environment` может использоваться для выполнения задач только в указанных окружениях, согласно определению [переменной `APP_ENV` окружения](/docs/{{version}}/configuration#environment-configuration):

    Schedule::command('emails:send')
                ->daily()
                ->environments(['staging', 'production']);

<a name="timezones"></a>
### Часовые пояса

Используя метод `timezone`, вы можете указать, что время запланированной задачи должно интерпретироваться в рамках переданного часового пояса:

    use Illuminate\Support\Facades\Schedule;

    Schedule::command('report:generate')
             ->timezone('America/New_York')
             ->at('2:00')

Если вы постоянно назначаете один и тот же часовой пояс для всех запланированных задач, то вы можете указать, какой часовой пояс должен быть назначен всем расписаниям, определив параметр `schedule_timezone` в файле конфигурации `app` вашего приложения:

    'timezone' => env('APP_TIMEZONE', 'UTC'),

    'schedule_timezone' => 'America/Chicago',

> [!WARNING]
> Помните, что в некоторых часовых поясах используется летнее время. Когда происходит переход на летнее время, ваша запланированная задача может запускаться дважды или даже не запускаться вообще. По этой причине мы рекомендуем по возможности избегать указаний часовых поясов при планировании.

<a name="preventing-task-overlaps"></a>
### Предотвращение дублирования задач

По умолчанию запланированные задачи будут выполняться, даже если предыдущий экземпляр задачи все еще выполняется. Чтобы предотвратить это, вы можете использовать метод `withoutOverlapping`:

    use Illuminate\Support\Facades\Schedule;

    Schedule::command('emails:send')->withoutOverlapping();

В этом примере команда `emails:send` [Artisan](artisan) будет запускаться каждую минуту при условии, что она еще не запущена. Метод `withoutOverlapping` особенно полезен, если у вас есть задачи, которые разнятся по времени выполнения, что не позволяет вам точно предсказать, сколько времени займет текущая задача.

При необходимости вы можете указать, сколько минут должно пройти до окончания блокировки «перекрывающихся» задач. По умолчанию срок блокировки истекает через 24 часа:

    Schedule::command('emails:send')->withoutOverlapping(10);

Внутри метод `withoutOverlapping` использует [кэш](/docs/{{version}}/cache) вашего приложения для получения блокировок. При необходимости вы можете очистить эти блокировки, используя команду Artisan `schedule:clear-cache`. Обычно это необходимо только в случае, если задача застревает из-за непредвиденной проблемы с сервером.

<a name="running-tasks-on-one-server"></a>
### Выполнение задач на одном сервере

> [!WARNING]
> Чтобы использовать этот функционал, ваше приложение должно использовать по умолчанию один из следующих драйверов кеша: `database`, `memcached`, `dynamodb`, или `redis`. Кроме того, все серверы должны взаимодействовать с одним и тем же центральным сервером кеширования.

Если планировщик вашего приложения работает на нескольких серверах, то вы можете ограничить выполнение запланированного задания только на одном сервере. Например, предположим, что у вас есть запланированная задача, по которой каждую пятницу вечером создается новый отчет. Если планировщик задач работает на трех рабочих серверах, запланированная задача будет запущена на всех трех серверах и трижды сгенерирует отчет. Не очень хорошо!

Чтобы указать, что задача должна выполняться только на одном сервере, используйте метод `onOneServer` при определении запланированной задачи. Первый сервер, который получит задачу, обеспечит атомарную блокировку задания, чтобы другие серверы не могли одновременно выполнять ту же задачу:

    use Illuminate\Support\Facades\Schedule;

    Schedule::command('report:generate')
                    ->fridays()
                    ->at('17:00')
                    ->onOneServer();

<a name="naming-unique-jobs"></a>
#### Именование заданий одного сервера

Иногда вам может потребоваться запланировать отправку одного и того же задания с разными параметрами, но при этом указать Laravel запускать каждую модификацию задания на одном сервере. Для этого вы можете присвоить каждому определению расписания уникальное имя с помощью метода `name`:

```php
Schedule::job(new CheckUptime('https://laravel.com'))
            ->name('check_uptime:laravel.com')
            ->everyFiveMinutes()
            ->onOneServer();

Schedule::job(new CheckUptime('https://vapor.laravel.com'))
            ->name('check_uptime:vapor.laravel.com')
            ->everyFiveMinutes()
            ->onOneServer();
```

Аналогично, для запланированных замыканий также необходимо присвоить имя, если они должны выполняться на одном сервере:

```php
Schedule::call(fn () => User::resetApiRequestCount())
    ->name('reset-api-request-count')
    ->daily()
    ->onOneServer();
```

<a name="background-tasks"></a>
### Фоновые задачи

По умолчанию, несколько задач, запланированных одновременно, будут выполняться последовательно в соответствии с порядком, которым они определены в вашем методе `schedule`. Если у вас есть длительные задачи, это может привести к тому, что последующие задачи начнутся намного позже, чем ожидалось. Если вы хотите запускать задачи в фоновом режиме в соответствии с планом, то вы можете использовать метод `runInBackground`:

    use Illuminate\Support\Facades\Schedule;

    Schedule::command('analytics:report')
             ->daily()
             ->runInBackground();

> [!WARNING]
> Метод `runInBackground` может использоваться только при планировании задач с помощью методов `command` и `exec`.

<a name="maintenance-mode"></a>
### Режим технического обслуживания

Запланированные задачи вашего приложения не будут выполняться, когда приложение находится в [режиме обслуживания](/docs/{{version}}/configuration#maintenance-mode), поскольку мы не хотим, чтобы ваши задачи мешали любому незавершенному процессу обслуживания, выполняющемуся на вашем сервере. Однако, если вы хотите принудительно запустить задачу даже в режиме обслуживания, то используйте метод `evenInMaintenanceMode` при определении задачи:

    Schedule::command('emails:send')->evenInMaintenanceMode();

<a name="schedule-groups"></a>
### Группировка задач

При определении нескольких запланированных задач со схожими конфигурациями вы можете использовать функцию группировки задач Laravel, чтобы избежать повторения одних и тех же настроек для каждой задачи. Группировка задач упрощает ваш код и обеспечивает согласованность связанных задач.

Чтобы создать группу запланированных задач, вызовите нужные методы настройки задачи, а затем метод `group`. Метод `group` принимает замыкание, отвечающее за определение задач, имеющих указанную конфигурацию:

```php
use Illuminate\Support\Facades\Schedule;

Schedule::daily()
    ->onOneServer()
    ->timezone('America/New_York')
    ->group(function () {
        Schedule::command('emails:send --force');
        Schedule::command('emails:prune');
    });
```

<a name="running-the-scheduler"></a>
## Запуск планировщика

Теперь, когда мы узнали, как определять планирование задачи, давайте обсудим, как же запускать их на нашем сервере. Команда `schedule:run` Artisan проанализирует все ваши запланированные задачи и определит, нужно ли их запускать, исходя из текущего времени сервера.

Итак, при использовании планировщика Laravel нам нужно добавить только одну конфигурационную запись cron на наш сервер, которая запускает команду `schedule:run` каждую минуту. Если вы не знаете, как добавить записи cron на свой сервер, то рассмотрите возможность использования такой службы, как [Laravel Forge](https://forge.laravel.com), которая может управлять записями cron за вас:

```shell
* * * * * cd /path-to-your-project && php artisan schedule:run >> /dev/null 2>&1
```

<a name="sub-minute-scheduled-tasks"></a>
### Задания с интервалом менее минуты

В большинстве операционных систем задания cron ограничены запуском не чаще одного раза в минуту. Тем не менее, планировщик задач Laravel позволяет вам запланировать выполнение заданий с более частыми интервалами, даже каждую секунду:

    use Illuminate\Support\Facades\Schedule;

    Schedule::call(function () {
        DB::table('recent_users')->delete();
    })->everySecond();

Когда в вашем приложении определены задания с интервалом менее минуты, команда `schedule:run` будет выполняться до конца текущей минуты, а не завершится немедленно. Это позволяет команде вызывать все необходимые задания с интервалом менее минуты в течение минуты.

Поскольку задания с интервалом менее минуты, которые выполняются дольше, чем ожидалось, могут задерживать выполнение последующих заданий, рекомендуется, чтобы все такие задания били помещены в очередь заданий или выполняли команды в фоновом режиме для обработки фактической задачи:

    use App\Jobs\DeleteRecentUsers;

    Schedule::job(new DeleteRecentUsers)->everyTenSeconds();

    Schedule::command('users:delete')->everyTenSeconds()->runInBackground();

<a name="interrupting-sub-minute-tasks"></a>
#### Прерывание задач с интервалом менее минуты:

Поскольку команда `schedule:run` выполняется в течение всей минуты при наличии задач с интервалом менее минуты, вам иногда может потребоваться прервать выполнение команды при развертывании вашего приложения. В противном случае экземпляр команды `schedule:run`, который уже выполняется, будет продолжать использовать код вашего приложения, развернутого ранее, пока не завершится текущая минута.

Для прерывания выполняющихся `schedule:run` вы можете добавить команду `schedule:interrupt` в сценарий развертывания вашего приложения. Эту команду следует вызвать после завершения развертывания вашего приложения:

```shell
php artisan schedule:interrupt
```

<a name="running-the-scheduler-locally"></a>
## Локальный запуск планировщика

Как правило, на локальной машине нет необходимости в добавлении записи cron планировщика. Вместо этого вы можете использовать команду `schedule:work` Artisan. Эта команда будет работать на переднем плане и вызывать планировщик каждую минуту, пока вы не завершите команду. Если определены задачи продолжительностью менее минуты, планировщик будет продолжать работать в течение каждой минуты для обработки этих задач:

```shell
php artisan schedule:work
```

<a name="task-output"></a>
## Результат выполнения задачи

Планировщик Laravel предлагает несколько удобных методов для работы с выводом результатов, созданных запланированными задачами. Во-первых, используя метод `sendOutputTo`, вы можете отправить результат в файл для последующей просмотра:

    use Illuminate\Support\Facades\Schedule;

    Schedule::command('emails:send')
             ->daily()
             ->sendOutputTo($filePath);

Если вы хотите добавить результат в указанный файл, то используйте метод `appendOutputTo`:

    Schedule::command('emails:send')
             ->daily()
             ->appendOutputTo($filePath);

Используя метод `emailOutputTo`, вы можете отправить результат по электронной почте на любой адрес. Перед отправкой результатов выполнения задачи по электронной почте вам следует настроить [почтовые службы](/docs/{{version}}/mail) Laravel:

    Schedule::command('report:generate')
             ->daily()
             ->sendOutputTo($filePath)
             ->emailOutputTo('taylor@example.com');

Если вы хотите отправить результат по электронной почте только в том случае, если запланированная (Artisan или системная) команда завершается ненулевым кодом возврата, используйте метод `emailOutputOnFailure`:

    Schedule::command('report:generate')
             ->daily()
             ->emailOutputOnFailure('taylor@example.com');

> [!WARNING]
> Методы `emailOutputTo`, `emailOutputOnFailure`, `sendOutputTo`, and `appendOutputTo` могут использоваться только при планировании задач с помощью методов `command` и `exec`.

<a name="task-hooks"></a>
## Хуки выполнения задачи

Используя методы `before` и `after`, вы можете указать замыкания, которые будут выполняться до и после выполнения запланированной задачи:

    use Illuminate\Support\Facades\Schedule;

    Schedule::command('emails:send')
             ->daily()
             ->before(function () {
                 // Задача готова к выполнению...
             })
             ->after(function () {
                 // Задача выполнена...
             });

Методы `onSuccess` и `onFailure` позволяют указать замыкания, которые будут выполняться в случае успешного или неудачного выполнения запланированной задачи. Ошибка означает, что запланированная (Artisan или системная) команда завершилась ненулевым кодом возврата:

    Schedule::command('emails:send')
             ->daily()
             ->onSuccess(function () {
                 // Задача успешно выполнена...
             })
             ->onFailure(function () {
                 // Не удалось выполнить задачу...
             });

Если из вашей команды доступен вывод результата, то вы можете получить к нему доступ в ваших хуках `after`, `onSuccess` или `onFailure`, указав тип экземпляра `Illuminate\Support\Stringable` в качестве аргумента `$output` замыкания при определении вашего хука:

    use Illuminate\Support\Stringable;

    Schedule::command('emails:send')
             ->daily()
             ->onSuccess(function (Stringable $output) {
                 // Задача успешно выполнена...
             })
             ->onFailure(function (Stringable $output) {
                 // Не удалось выполнить задачу...
             });

<a name="pinging-urls"></a>
#### Пингование URL-адресов

Используя методы `pingBefore` и `thenPing`, планировщик может автоматически пинговать по-указанному URL до или после выполнения задачи. Этот метод полезен для уведомления внешней службы, такой как [Envoyer](https://envoyer.io), о том, что ваша запланированная задача запущена или завершена:

    Schedule::command('emails:send')
             ->daily()
             ->pingBefore($url)
             ->thenPing($url);

Методы `pingOnSuccess` и `pingOnFailure` можно использовать для проверки связи с заданным URL-адресом только в случае успешного или неудачного выполнения задачи. Сбой означает, что запланированная Artisan или системная команда завершилась с ненулевым кодом выхода:

    Schedule::command('emails:send')
             ->daily()
             ->pingOnSuccess($successUrl)
             ->pingOnFailure($failureUrl);

Методы `pingBeforeIf`, `thenPingIf`, `pingOnSuccessIf` и `pingOnFailureIf` могут использоваться для проверки связи с заданным URL-адресом только в том случае, если заданное условие `true`:

    Schedule::command('emails:send')
             ->daily()
             ->pingBeforeIf($condition, $url)
             ->thenPingIf($condition, $url);             

    Schedule::command('emails:send')
             ->daily()
             ->pingOnSuccessIf($condition, $successUrl)
             ->pingOnFailureIf($condition, $failureUrl);

<a name="events"></a>
## События

Laravel отправляет различные [события](/docs/{{version}}/events) в процессе планирования. Вы можете [определить прослушиватели](/docs/{{version}}/events) для любого из следующих событий:

| Наименование события                                        |
| ----------------------------------------------------------- |
| `Illuminate\Console\Events\ScheduledTaskStarting`           |
| `Illuminate\Console\Events\ScheduledTaskFinished`           |
| `Illuminate\Console\Events\ScheduledBackgroundTaskFinished` |
| `Illuminate\Console\Events\ScheduledTaskSkipped`            |
| `Illuminate\Console\Events\ScheduledTaskFailed`             |
