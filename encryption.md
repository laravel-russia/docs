---
git: ead3a5b4b11c267f20ee1065eb3f9aa98fc986e1
---

# Шифрование

<a name="introduction"></a>
## Введение

Сервисы шифрования Laravel предоставляют простой и удобный интерфейс для шифрования и дешифрования текста через OpenSSL с использованием шифрования AES-256 и AES-128. Все зашифрованные значения Laravel подписываются с использованием кода аутентификации сообщения (MAC), поэтому их базовое значение не может быть изменено или подделано после шифрования.

<a name="configuration"></a>
## Конфигурирование

Перед использованием шифровальщика Laravel вы должны установить параметр `key` в конфигурационном файле `config/app.php`. Это значение конфигурации управляется переменной окружения `APP_KEY`. Вы должны использовать команду `php artisan key:generate` для генерации значения этой переменной, поскольку команда `key:generate` будет использовать безопасный генератор случайных байтов PHP для создания криптографически безопасного ключа для вашего приложения. Обычно значение переменной среды `APP_KEY` генерируется для вас во время [установки Laravel](/docs/{{version}}/installation).

<a name="gracefully-rotating-encryption-keys"></a>
### Плавная смена ключей шифрования

При изменении ключа шифрования вашего приложения все сеансы аутентификации пользователей будут завершены. Это происходит потому, что каждый cookie, включая сессионные, шифруется Laravel. Кроме того, данные, зашифрованные с использованием предыдущего ключа, больше не будут доступны для расшифровки.

Для решения этой проблемы Laravel предоставляет возможность указать предыдущие ключи шифрования в переменной окружения `APP_PREVIOUS_KEYS` вашего приложения. Эта переменная может содержать список предыдущих ключей, разделенных запятыми:

```ini
APP_KEY="base64:J63qRTDLub5NuZvP+kb8YIorGS6qFYHKVo6u7179stY="
APP_PREVIOUS_KEYS="base64:2nLsGFGzyoae2ax3EF2Lyq/hH6QghBGLIq5uL+Gp8/w="
```

Когда вы устанавливаете эту переменную окружения, Laravel всегда будет использовать "текущий" ключ для шифрования данных. Однако при расшифровке Laravel сначала попытается использовать текущий ключ, а если это не удастся, то попробует все предыдущие ключи, пока не найдет подходящий.

Этот метод плавной расшифровки позволяет пользователям продолжать использовать ваше приложение без перерывов, даже если вы поменяли ключ шифрования.

<a name="using-the-encrypter"></a>
## Использование шифровальщика

<a name="encrypting-a-value"></a>
#### Шифрование значения

Вы можете зашифровать значение, используя метод `encryptString` фасада `Crypt`. Все значения будут зашифрованы с использованием OpenSSL и шифра `AES-256-CBC`. Кроме того, все зашифрованные значения подписываются кодом аутентификации сообщения (MAC). Встроенный код аутентификации сообщений предотвратит расшифровку любых значений, которые были подделаны злоумышленниками:

    <?php

    namespace App\Http\Controllers;

    use Illuminate\Http\RedirectResponse;
    use Illuminate\Http\Request;
    use Illuminate\Support\Facades\Crypt;

    class DigitalOceanTokenController extends Controller
    {
        /**
         * Сохраните DigitalOcean API-токен пользователя.
         */
        public function store(Request $request): RedirectResponse
        {
            $request->user()->fill([
                'token' => Crypt::encryptString($request->token),
            ])->save();

            return redirect('/secrets');
        }
    }

<a name="decrypting-a-value"></a>
#### Расшифровка значения

Вы можете расшифровать значения, используя метод `decryptString` фасада `Crypt`. Если значение не может быть правильно расшифровано, например, когда код аутентификации сообщения недействителен, будет выброшено исключение `Illuminate\Contracts\Encryption\DecryptException`:

    use Illuminate\Contracts\Encryption\DecryptException;
    use Illuminate\Support\Facades\Crypt;

    try {
        $decrypted = Crypt::decryptString($encryptedValue);
    } catch (DecryptException $e) {
        // ...
    }
