---
git: 9f36b02f2c2968ad2c6945df79d9eaf31dfdd224
---

# Тестирование · Начало работы

<a name="introduction"></a>
## Введение

Laravel построен с учетом требований тестирования. Поддержка тестирования с помощью PHPUnit включена прямо из коробки, и файл `phpunit.xml` уже настроен для вашего приложения. Фреймворк также поставляется с удобными вспомогательными методами, позволяющими выразительно тестировать ваши приложения.

По умолчанию каталог `tests` вашего приложения содержит два каталога: `Feature` и `Unit`. Модульные (юнит) тесты – это тесты, которые фокусируются на очень небольшой изолированной части вашего кода. Фактически, большинство модульных тестов, вероятно, сосредоточены на одном методе. Тесты в каталоге «Unit» тестов не загружают ваше приложение Laravel и, следовательно, не могут получить доступ к базе данных вашего приложения или другим службам фреймворка.

Функциональные тесты могут тестировать большую часть вашего кода, включая взаимодействие нескольких объектов друг с другом, или даже целый HTTP-запрос, возвращающий JSON. **Как правило, большинство ваших тестов должны быть функциональными. Эти типы тестов обеспечивают максимальную уверенность в том, что ваша система в целом работает должным образом.**

Файл `ExampleTest.php` находится в каталогах тестов `Feature` и `Unit`. После установки нового приложения Laravel выполните команды `vendor/bin/phpunit` или `php artisan test` из командной строки для запуска ваших тестов.

<a name="environment"></a>
## Окружение

При запуске тестов Laravel автоматически устанавливает [конфигурацию окружения](/docs/{{version}}/configuration#environment-configuration) в `testing` благодаря переменной окружения, определенной в файле `phpunit.xml`. Laravel также автоматически настраивает сеанс и кеш для драйвера `array`, чтобы данные сеанса или кэша не сохранялись во время тестирования.

При необходимости вы можете определять другие значения конфигурации среды тестирования. Переменные окружения `testing` могут быть настроены в файле `phpunit.xml`, но перед запуском тестов не забудьте очистить кеш конфигурации с помощью Artisan-команды `config:clear`.

<a name="the-env-testing-environment-file"></a>
#### Переменная окружения `.env.testing`

Кроме того, вы можете создать файл `.env.testing` в корне вашего проекта. Этот файл будет использоваться вместо файла `.env` при запуске тестов Pest и PHPUnit или выполнении команд Artisan с опцией --env=testing.

<a name="creating-tests"></a>
## Создание тестов

Чтобы сгенерировать новый тест, используйте [Artisan](artisan)-команду `make:test`. Эта команда поместит новый класс теста в каталог `tests/Feature` вашего приложения:

```shell
php artisan make:test UserTest
```

Если вы хотите создать тест в каталоге `tests/Unit`, то используйте параметр `--unit` при выполнении команды `make:test`:

```shell
php artisan make:test UserTest --unit
```

> [!NOTE]
> Тестовые заглушки можно настроить с помощью [публикации заготовок](/docs/{{version}}/artisan#stub-customization).

После создания теста вы можете определить его, как обычно, используя Pest или PHPUnit. Чтобы запустить тесты, выполните команду `vendor/bin/pest`, `vendor/bin/phpunit` или `php artisan test` со своего терминала:

```php tab=Pest
<?php

test('basic', function () {
    expect(true)->toBeTrue();
});
```

```php tab=PHPUnit
<?php

namespace Tests\Unit;

use PHPUnit\Framework\TestCase;

class ExampleTest extends TestCase
{
    /**
     * A basic test example.
     */
    public function test_basic_test(): void
    {
        $this->assertTrue(true);
    }
}
```

> [!WARNING]
> Если вы определяете свои собственные методы `setUp` / `tearDown` в тестовом классе, обязательно вызывайте соответствующие методы `parent::setUp()` / `parent::tearDown()` родительского класса. Обычно вы должны вызывать `parent::setUp()` в начале своего собственного метода `setUp`, а `parent::tearDown()` в конце вашего метода `tearDown`.

<a name="running-tests"></a>
## Запуск тестов

Как упоминалось ранее, после того, как вы написали тесты, вы можете запускать их с помощью `pest` или`phpunit`:

```shell tab=Pest
./vendor/bin/pest
```

```shell tab=PHPUnit
./vendor/bin/phpunit
```

В дополнение к командам `pest` или `phpunit`, вы можете использовать команду `test` Artisan для запуска ваших тестов. Тестер Artisan отображает подробные отчеты о тестах для упрощения разработки и отладки:

```shell
php artisan test
```

Любые аргументы, которые могут быть переданы командам `pest` или `phpunit`, также могут быть переданы команде Artisan `test`:

```shell
php artisan test --testsuite=Feature --stop-on-failure
```

<a name="running-tests-in-parallel"></a>
### Параллельное выполнение тестов

По умолчанию Laravel и PHPUnit выполняют ваши тесты последовательно в рамках одного процесса. Однако вы можете значительно сократить время выполнения ваших тестов, запуская их параллельно в нескольких процессах. Для начала вам следует установить пакет Composer `brianium/paratest` как "dev" зависимость. Затем при выполнении команды `test` Artisan вы должны включить опцию `--parallel`:

```shell
composer require brianium/paratest --dev

php artisan test --parallel
```

По умолчанию Laravel создает столько процессов, сколько ядер ЦП доступно на вашем компьютере. Однако вы можете настроить количество процессов, используя параметр `--processes`:

```shell
php artisan test --parallel --processes=4
```

> [!WARNING]
> При параллельном запуске тестов некоторые параметры PHPUnit (такие, как `--do-not-cache-result`) могут быть недоступны.

<a name="parallel-testing-and-databases"></a>
#### Параллельное тестирование и базы данных

При условии, что вы настроили основное подключение к базе данных, Laravel автоматически обрабатывает создание и миграцию тестовой базы данных для каждого параллельного процесса, в котором выполняются ваши тесты. К тестовым базам данных будет добавлен суффикс, уникальный для каждого процесса. Например, если у вас есть два параллельных тестовых процесса, Laravel создаст и будет использовать тестовые базы данных `your_db_test_1` и `your_db_test_2`.

По умолчанию тестовые базы данных сохраняются между вызовами команды `test` Artisan, чтобы их можно было использовать снова при последующих вызовах `test`. Однако вы можете пересоздать их, используя параметр `--recreate-databases`:

```shell
php artisan test --parallel --recreate-databases
```

<a name="parallel-testing-hooks"></a>
#### Хуки параллельного тестирования

Иногда требуется подготовить определенные ресурсы, используемые тестами вашего приложения, чтобы их можно было безопасно использовать в нескольких процессах тестирования.

Используя фасад `ParallelTesting`, вы можете указать код, который будет выполняться в `setUp` и `tearDown` процесса или тестового класса. Переданные замыкания получат переменные `$token` и `$testCase`, которые содержат токен процесса и текущий тестовый класс, соответственно:

    <?php

    namespace App\Providers;

    use Illuminate\Support\Facades\Artisan;
    use Illuminate\Support\Facades\ParallelTesting;
    use Illuminate\Support\ServiceProvider;
    use PHPUnit\Framework\TestCase;

    class AppServiceProvider extends ServiceProvider
    {
        /**
         * Загрузка любых служб приложения.
         */
        public function boot(): void
        {
            ParallelTesting::setUpProcess(function (int $token) {
                // ...
            });

            ParallelTesting::setUpTestCase(function (int $token, TestCase $testCase) {
                // ...
            });

            // Выполнится при создании тестовой базы данных...
            ParallelTesting::setUpTestDatabase(function (string $database, int $token) {
                Artisan::call('db:seed');
            });

            ParallelTesting::tearDownTestCase(function (int $token, TestCase $testCase) {
                // ...
            });

            ParallelTesting::tearDownProcess(function (int $token) {
                // ...
            });
        }
    }

<a name="accessing-the-parallel-testing-token"></a>
#### Доступ к токену процесса параллельного тестирования

Если вы хотите получить доступ к текущему "токену" параллельного процесса из любого другого места в коде вашего приложения для тестирования, вы можете использовать метод `token`. Этот токен представляет собой уникальный строковый идентификатор для каждого индивидуального тестового процесса и может использоваться для сегментации ресурсов между параллельными тестовыми процессами. Например, Laravel автоматически добавляет этот токен в конец имен тестовых баз данных, созданных каждым параллельным тестовым процессом:

    $token = ParallelTesting::token();

<a name="reporting-test-coverage"></a>
### Отчет о покрытии тестами

> [!WARNING]
> Для использования этой функции требуется [Xdebug](https://xdebug.org) или [PCOV](https://pecl.php.net/package/pcov).

При запуске тестов вашего приложения вам может потребоваться определить, действительно ли ваши тесты охватывают код приложения и насколько много кода приложения используется при выполнении ваших тестов. Для этого вы можете использовать опцию `--coverage` при вызове команды `test`:

```shell
php artisan test --coverage
```

<a name="enforcing-a-minimum-coverage-threshold"></a>
#### Установка минимального порога покрытия

Вы можете использовать опцию `--min`, чтобы задать минимальный порог покрытия тестами для вашего приложения. Процесс завершит выполнение с ошибкой, если этот порог не будет достигнут:

```shell
php artisan test --coverage --min=80.3
```

<a name="profiling-tests"></a>
### Профилирование тестов

Запуская тестовый раннер Artisan, вы также можете узнать, какие из ваших тестов работают медленно. Вызовите команду `test` с опцией `--profile`, чтобы получить список десяти самых медленных тестов вашего приложения, что позволит вам легко выяснить, какие тесты можно улучшить, чтобы ускорить выполнение:

```shell
php artisan test --profile
```
