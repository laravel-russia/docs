---
git: 43a416d09aa91530e8d6f24532acd7509c67ce82
---

# Laravel Folio

<a name="introduction"></a>
## Введение

[Laravel Folio](https://github.com/laravel/folio) - это мощный роутер на основе страниц, разработанный для упрощения маршрутизации в приложениях Laravel. С помощью Laravel Folio создание маршрута становится таким же простым, как создание шаблона Blade в директории `resources/views/pages` вашего приложения.

Например, чтобы создать страницу, которая будет доступна по URL `/greeting`, просто создайте файл `greeting.blade.php` в директории `resources/views/pages` вашего приложения:

```php
<div>
    Hello World
</div>
```

<a name="installation"></a>
## Установка

Для начала установите Folio в ваш проект, используя менеджер пакетов Composer:

```bash
composer require laravel/folio
```

После установки Folio, вы можете выполнить команду Artisan `folio:install`, которая установит провайдера службы Folio в вашем приложении. Этот провайдер регистрирует директорию, в которой Folio будет искать маршруты / страницы:

```bash
php artisan folio:install
```

<a name="page-paths-uris"></a>
### Пути страниц / URI

По умолчанию Folio обслуживает страницы из директории `resources/views/pages` вашего приложения, но вы можете настроить эти директории в методе `boot` провайдера службы Folio.

Например, иногда удобно указать несколько путей Folio в одном и том же приложении Laravel. Вы можете хотеть иметь отдельную директорию для страниц Folio для раздела "администратор", а также использовать другую директорию для остальных страниц вашего приложения.

Вы можете сделать это с помощью методов `Folio::path` и `Folio::uri`. Метод `path` регистрирует директорию, которую Folio будет сканировать для поиска страниц при маршрутизации входящих HTTP-запросов, а метод `uri` указывает "базовый URI" для этой директории страниц:

```php
use Laravel\Folio\Folio;

Folio::path(resource_path('views/pages/guest'))->uri('/');

Folio::path(resource_path('views/pages/admin'))
    ->uri('/admin')
    ->middleware([
        '*' => [
            'auth',
            'verified',

            // ...
        ],
    ]);
```

<a name="subdomain-routing"></a>
### Маршрутизация по поддоменам

Вы также можете маршрутизировать страницы на основе поддомена входящего запроса. Например, вы можете хотеть маршрутизировать запросы от `admin.example.com` в другую директорию страниц Folio, чем остальные страницы Folio вашего приложения. Для этого используйте метод `domain` после метода `Folio::path`:

```php
use Laravel\Folio\Folio;

Folio::domain('admin.example.com')
    ->path(resource_path('views/pages/admin'));
```

Метод `domain` также позволяет захватывать части домена или поддомена как параметры. Эти параметры будут вставлены в ваш шаблон страницы:

```php
use Laravel\Folio\Folio;

Folio::domain('{account}.example.com')
    ->path(resource_path('views/pages/admin'));
```

<a name="creating-routes"></a>
## Создание маршрутов

Вы можете создать маршрут Folio, разместив шаблон Blade в любой из директорий, зарегистрированных для Folio. По умолчанию Folio регистрирует директорию `resources/views/pages`, но вы можете настроить эти директории в методе `boot` провайдера службы Folio.

После размещения шаблона Blade в зарегистрированной для Folio директории, вы можете немедленно получить к нему доступ через браузер. Например, страница, размещенная в `pages/schedule.blade.php`, может быть доступна в вашем браузере по адресу `http://example.com/schedule`.

Чтобы быстро просмотреть список всех ваших страниц / маршрутов Folio, вы можете выполнить команду Artisan `folio:list`:

```bash
php artisan folio:list
```

<a name="nested-routes"></a>
### Вложенные маршруты

Вы можете создать вложенный маршрут, создав одну или несколько директорий внутри одной из директорий Folio. Например, чтобы создать страницу, которая будет доступна по `/user/profile`, создайте шаблон `profile.blade.php` в директории `pages/user`:

```bash
php artisan folio:page user/profile

# pages/user/profile.blade.php → /user/profile
```

<a name="index-routes"></a>
### Маршруты индекса

Иногда вы можете хотеть сделать определенную страницу "индексом" для директории. Поместив шаблон `index.blade.php` в директорию Folio, все запросы к корню этой директории будут направлены на эту страницу:

```bash
php artisan folio:page index
# pages/index.blade.php → /

php artisan folio:page users/index
# pages/users/index.blade.php → /users
```

<a name="route-parameters"></a>
## Параметры маршрута

Часто вам нужно будет внедрить сегменты URL входящего запроса в вашу страницу, чтобы вы могли взаимодействовать с ними. Например, вам может потребоваться получить доступ к "ID" пользователя, чей профиль отображается. Для этого вы можете заключить сегмент имени файла страницы в квадратные скобки:

```bash
php artisan folio:page "users/[id]"

# pages/users/[id].blade.php → /users/1
```

Захваченные сегменты можно получить как переменные внутри вашего шаблона Blade:

```html
<div>
    Пользователь {{ $id }}
</div>
```

Для захвата нескольких сегментов вы можете использовать префикс `...` перед заключенным в скобки сегментом:

```bash
php artisan folio:page "users/[...ids]"

# pages/users/[...ids].blade.php → /users/1/2/3
```

При захвате нескольких сегментов захваченные сегменты будут вставлены в страницу как массив:

```html
<ul>
    @foreach ($ids as $id)
        <li>Пользователь {{ $id }}</li>
    @endforeach
</ul>
```

<a name="route-model-binding"></a>
## Привязка модели к маршруту

Если подстановочный сегмент имени файла вашего шаблона страницы соответствует одной из моделей Eloquent вашего приложения, Folio автоматически использует возможности привязки модели Laravel и попытается вставить экземпляр разрешенной модели в вашу страницу:

```bash
php artisan folio:page "users/[User]"

# pages/users/[User].blade.php → /users/1
```

Захваченные модели можно получить как переменные внутри вашего шаблона Blade. Имя переменной модели будет преобразовано в "camel case":

```html
<div>
    Пользователь {{ $user->id }}
</div>
```

#### Настройка ключа

Иногда вы можете хотеть разрешать связанные модели Eloquent, используя столбец, отличный от `id`. Для этого вы можете указать столбец в имени файла страницы. Например, страница с именем `[Post:slug].blade.php` будет пытаться разрешить привязанную модель через столбец `slug`, а не столбец `id`.

На Windows вы должны использовать `-` для разделения имени модели и ключа: `[Post-slug].blade.php`.

#### Местоположение модели

По умолчанию Folio будет искать вашу модель в директории `app/Models` вашего приложения. Однако, при необходимости, вы можете указать полное имя класса модели в имени файла вашего шаблона:

```bash
php artisan folio:page "users/[.App.Models.User]"

# pages/users/[.App.Models.User].blade.php → /users/1
```

<a name="soft-deleted-models"></a>
### Модели с мягким удалением

По умолчанию модели, которые были удалены с помощью мягкого удаления, не извлекаются при разрешении неявных привязок моделей. Однако, если вы хотите, вы можете указать Folio извлекать удаленные модели с помощью функции `withTrashed` в шаблоне вашей страницы:

```php
<?php

use function Laravel\Folio\{withTrashed};

withTrashed();

?>

<div>
    Пользователь {{ $user->id }}
</div>
```

<a name="render-hooks"></a>
## Обработчики отображения

По умолчанию Folio возвращает содержимое шаблона Blade страницы как ответ на входящий запрос. Однако вы можете настроить ответ, вызвав функцию `render` внутри шаблона страницы.

Функция `render` принимает замыкание, которое будет получать экземпляр `View`, который рендерится Folio, что позволяет вам добавлять дополнительные данные в представление или настраивать весь ответ. Помимо экземпляра `View`, в замыкание `render` также будут переданы дополнительные параметры маршрута или связывания модели:

```php
<?php

use App\Models\Post;
use Illuminate\Support\Facades\Auth;
use Illuminate\View\View;

use function Laravel\Folio\render;

render(function (View $view, Post $post) {
    if (! Auth::user()->can('view', $post)) {
        return response('Unauthorized', 403);
    }

    return $view->with('photos', $post->author->photos);
}); ?>

<div>
    {{ $post->content }}
</div>

<div>
    Этот автор также сделал {{ count($photos) }} фотографий.
</div>
```

<a name="named-routes"></a>
## Именованные маршруты

Вы можете задать имя маршруту для определенной страницы, используя функцию `name`:

```php
<?php

use function Laravel\Folio\name;

name('users.index');
```

Как и в случае с именованными маршрутами Laravel, вы можете использовать функцию `route` для создания URL-адресов для страниц Folio, которым было присвоено имя:

```php
<a href="{{ route('users.index') }}">
    Все пользователи
</a>
```

Если у страницы есть параметры, вы можете просто передать их значения функции `route`:

```php
route('users.show', ['user' => $user]);
```

<a name="middleware"></a>
## Промежуточное ПО (Middleware)

Вы можете применить промежуточное ПО к определенной странице, вызвав функцию `middleware` внутри шаблона страницы:

```php
<?php

use function Laravel\Folio\{middleware};

middleware(['auth', 'verified']);

?>

<div>
    Панель управления
</div>
```

Или, чтобы применить промежуточное ПО к группе страниц, вы можете цеплять метод `middleware` после вызова метода `Folio::path`.

Чтобы указать, к каким страницам следует применить промежуточное ПО, массив промежуточного ПО может быть разделен с использованием соответствующих шаблонов URL-адресов страниц, к которым оно должно быть применено. Символ `*` может быть использован как символ подстановки:

```php
use Laravel\Folio\Folio;

Folio::path(resource_path('views/pages'))->middleware([
    'admin/*' => [
        'auth',
        'verified',

        // ...
    ],
]);
```

Вы можете включить замыкания в массив промежуточного ПО, чтобы определить анонимное промежуточное ПО:

```php
use Closure;
use Illuminate\Http\Request;
use Laravel\Folio\Folio;

Folio::path(resource_path('views/pages'))->middleware([
    'admin/*' => [
        'auth',
        'verified',

        function (Request $request, Closure $next) {
            // ...

            return $next($request);
        },
    ],
]);
```

<a name="route-caching"></a>
## Кэширование маршрутов

При использовании Folio вы всегда должны использовать [возможности кэширования маршрутов Laravel](/docs/{{version}}/routing#route-caching). Folio прослушивает команду Artisan `route:cache`, чтобы убедиться, что определения страниц Folio и имена маршрутов должны быть правильно закэшированы для максимальной производительности.
